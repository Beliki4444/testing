# Задание: Тестирование с использованием Vitest

## Цель задания

Научиться писать unit-тесты с использованием фреймворка Vitest, освоить структурирование тестов через `describe` и `it`.

## Теория

### describe()
`describe()` - используется для группировки связанных тестов. Это помогает организовать тесты логически и делает вывод результатов более читаемым.

```javascript
describe('название группы тестов', () => {
  // здесь размещаются тесты
});
```

**Преимущества:**
- Логическая группировка тестов
- Можно вкладывать друг в друга для создания иерархии
- Улучшает читаемость отчетов о тестировании

### it() или test()
`it()` (или `test()`) - описывает конкретный тестовый случай. Название должно четко описывать, что проверяется.

```javascript
it('should do something specific', () => {
  // код теста с проверками
});
```

### expect()
`expect()` - создает утверждение для проверки результата. После expect идут матчеры (toBe, toEqual, toThrow и т.д.)

```javascript
expect(result).toBe(expectedValue);
expect(array).toHaveLength(3);
expect(() => someFunction()).toThrow('error message');
```

## Часть 1: Изучение примеров

1. Откройте файл `tests/userValidator.test.js`
2. Изучите 6 примеров использования `describe` и `it`:
   - Простая группировка тестов
   - Вложенные describe для группировки по сценариям
   - Тестирование функций с массивами
   - Тестирование строковых операций
   - Тестирование сложной функции с несколькими проверками
   - Тестирование вычислений

3. Запустите тесты командой:
```bash
npm test
```

4. Изучите вывод тестов и обратите внимание на иерархическую структуру

## Часть 2: Практическое задание

Создайте новый файл `src/arrayUtils.js` со следующими функциями:

```javascript
/**
 * Находит максимальное число в массиве
 * @param {Array<number>} numbers - Массив чисел
 * @returns {number} - Максимальное число
 * @throws {Error} - Если массив пустой или не является массивом
 */
export function findMax(numbers) {
  // TODO: реализовать
}

/**
 * Удаляет дубликаты из массива
 * @param {Array} array - Исходный массив
 * @returns {Array} - Массив без дубликатов
 */
export function removeDuplicates(array) {
  // TODO: реализовать
}

/**
 * Группирует элементы массива по заданному размеру
 * Пример: chunkArray([1,2,3,4,5], 2) => [[1,2], [3,4], [5]]
 * @param {Array} array - Исходный массив
 * @param {number} size - Размер группы
 * @returns {Array<Array>} - Массив групп
 * @throws {Error} - Если size меньше 1
 */
export function chunkArray(array, size) {
  // TODO: реализовать
}

/**
 * Сортирует массив объектов по указанному полю
 * @param {Array<Object>} array - Массив объектов
 * @param {string} field - Поле для сортировки
 * @param {string} order - 'asc' или 'desc'
 * @returns {Array<Object>} - Отсортированный массив
 */
export function sortByField(array, field, order = 'asc') {
  // TODO: реализовать
}
```

## Часть 3: Написание тестов

Создайте файл `tests/arrayUtils.test.js` и напишите тесты для каждой функции:

### Требования к тестам:

1. **Для findMax**:
   - Используйте `describe('findMax', () => {...})` для группировки
   - Напишите минимум 5 тестов:
     - Поиск максимума в массиве положительных чисел
     - Поиск максимума в массиве с отрицательными числами
     - Массив с одним элементом
     - Проверка выброса ошибки для пустого массива
     - Проверка выброса ошибки для не-массива

2. **Для removeDuplicates**:
   - Используйте `describe` и вложенные `describe` для группировки по типам данных
   - Напишите тесты для:
     - Массива чисел с дубликатами
     - Массива строк с дубликатами
     - Массива без дубликатов
     - Пустого массива

3. **Для chunkArray**:
   - Протестируйте различные размеры групп
   - Проверьте случай, когда массив не делится нацело
   - Проверьте выброс ошибки для size < 1

4. **Для sortByField**:
   - Протестируйте сортировку по возрастанию и убыванию
   - Проверьте сортировку чисел и строк
   - Проверьте работу с пустым массивом

## Часть 4: Запуск и проверка

1. Реализуйте все функции в `src/arrayUtils.js`
2. Напишите все тесты в `tests/arrayUtils.test.js`
3. Запустите тесты:
```bash
npm test
```

4. Убедитесь, что все тесты проходят (зеленый цвет)

5. Запустите UI для визуализации:
```bash
npm run test:ui
```

6. Проверьте покрытие кода:
```bash
npm run test:coverage
```

## Критерии оценки

- ✅ Все функции реализованы корректно
- ✅ Написано минимум 20 тестов
- ✅ Использованы `describe` для группировки тестов
- ✅ Использованы вложенные `describe` там, где это уместно
- ✅ Все тесты проходят
- ✅ Тесты покрывают как успешные сценарии, так и крайние случаи
- ✅ Проверены выбросы ошибок где необходимо

## Дополнительное задание (по желанию)

Создайте функцию `calculateStatistics(numbers)`, которая возвращает объект со статистикой:
```javascript
{
  min: number,
  max: number,
  average: number,
  median: number,
  count: number
}
```

Напишите для неё полный набор тестов, используя структуру с вложенными `describe`.

## Полезные ссылки

- [Документация Vitest](https://vitest.dev/)
- [API тестирования](https://vitest.dev/api/)
- [Матчеры expect](https://vitest.dev/api/expect.html)

## Вопросы для самопроверки

1. В чем разница между `toBe()` и `toEqual()`?
2. Когда следует использовать вложенные `describe`?
3. Как протестировать функцию, которая выбрасывает ошибку?
4. Зачем группировать тесты через `describe`?
5. Что такое покрытие кода и почему это важно?
